# Nand 2 Tetris:
## Implementing a computer from the ground up, starting with  basic logic gates

### Purpose

The purpose of this course is to implement all the parts of a computer in order to eventually be able to compile and code in a simulated hardware environment.

### Rationale

The reasoning behind taking this course lies mainly in gaining a deeper understanding in the basic elements of computer hardware that are necessary for it to properly function, and to learn how to more efficiently design code at low levels which will give a greater understanding of why things are done as they are at increasingly higher levels (for example, in C, or even higher, in Python).

I believe I will also develop my logical thinking skills through the design of the various elements, starting from even the most basic gates (And, Or, Not, etc.).

### Contents

#### Week 1:

Boolean Logic Gates, starting with simple gates based on NAND. Gates include And, Or, Xor, Not, Mux, Dmux, and various 4/8 way and 16 bit implementations of these.

#### Week 2:

Boolean Arithmetic and arithmetic gates, including half/full adders, 16 bit adders, incrementors, and a simple functioning ALU chip.

#### Week 3:

Dealing with Registers and Ram and Building a Counter. Here we introduce the concept of DFFs.

#### Week 4:

Machine language. Writing code in assembly in order to manipulate I/O (Keyboard and Screen devices)

#### Week 5:

Computer implementation. CPU, and RAM chips implemented, and functioning Computer with ROM chip built.

#### Week 6:

Assembler. A python driven assembler was built from scratch in order to conver hack assembly files (.asm) into usable machine code in .hack files. It was a good chance for me to practise some new things like using type hinting and implementing a few new algorithms. I tried to use some objects to drive some code as well.